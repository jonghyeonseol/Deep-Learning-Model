[
    {
        "label": "torch",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torch",
        "description": "torch",
        "detail": "torch",
        "documentation": {}
    },
    {
        "label": "torch.nn",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torch.nn",
        "description": "torch.nn",
        "detail": "torch.nn",
        "documentation": {}
    },
    {
        "label": "torch.nn.functional",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torch.nn.functional",
        "description": "torch.nn.functional",
        "detail": "torch.nn.functional",
        "documentation": {}
    },
    {
        "label": "math",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "math",
        "description": "math",
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "torchvision",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torchvision",
        "description": "torchvision",
        "detail": "torchvision",
        "documentation": {}
    },
    {
        "label": "torchvision.transforms",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torchvision.transforms",
        "description": "torchvision.transforms",
        "detail": "torchvision.transforms",
        "documentation": {}
    },
    {
        "label": "DataLoader",
        "importPath": "torch.utils.data",
        "description": "torch.utils.data",
        "isExtraImport": true,
        "detail": "torch.utils.data",
        "documentation": {}
    },
    {
        "label": "random_split",
        "importPath": "torch.utils.data",
        "description": "torch.utils.data",
        "isExtraImport": true,
        "detail": "torch.utils.data",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "matplotlib.pyplot",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.pyplot",
        "description": "matplotlib.pyplot",
        "detail": "matplotlib.pyplot",
        "documentation": {}
    },
    {
        "label": "matplotlib.patches",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.patches",
        "description": "matplotlib.patches",
        "detail": "matplotlib.patches",
        "documentation": {}
    },
    {
        "label": "Circle",
        "importPath": "matplotlib.patches",
        "description": "matplotlib.patches",
        "isExtraImport": true,
        "detail": "matplotlib.patches",
        "documentation": {}
    },
    {
        "label": "FancyArrowPatch",
        "importPath": "matplotlib.patches",
        "description": "matplotlib.patches",
        "isExtraImport": true,
        "detail": "matplotlib.patches",
        "documentation": {}
    },
    {
        "label": "Rectangle",
        "importPath": "matplotlib.patches",
        "description": "matplotlib.patches",
        "isExtraImport": true,
        "detail": "matplotlib.patches",
        "documentation": {}
    },
    {
        "label": "FancyBboxPatch",
        "importPath": "matplotlib.patches",
        "description": "matplotlib.patches",
        "isExtraImport": true,
        "detail": "matplotlib.patches",
        "documentation": {}
    },
    {
        "label": "Circle",
        "importPath": "matplotlib.patches",
        "description": "matplotlib.patches",
        "isExtraImport": true,
        "detail": "matplotlib.patches",
        "documentation": {}
    },
    {
        "label": "FancyArrowPatch",
        "importPath": "matplotlib.patches",
        "description": "matplotlib.patches",
        "isExtraImport": true,
        "detail": "matplotlib.patches",
        "documentation": {}
    },
    {
        "label": "Circle",
        "importPath": "matplotlib.patches",
        "description": "matplotlib.patches",
        "isExtraImport": true,
        "detail": "matplotlib.patches",
        "documentation": {}
    },
    {
        "label": "FancyBboxPatch",
        "importPath": "matplotlib.patches",
        "description": "matplotlib.patches",
        "isExtraImport": true,
        "detail": "matplotlib.patches",
        "documentation": {}
    },
    {
        "label": "ConnectionPatch",
        "importPath": "matplotlib.patches",
        "description": "matplotlib.patches",
        "isExtraImport": true,
        "detail": "matplotlib.patches",
        "documentation": {}
    },
    {
        "label": "Rectangle",
        "importPath": "matplotlib.patches",
        "description": "matplotlib.patches",
        "isExtraImport": true,
        "detail": "matplotlib.patches",
        "documentation": {}
    },
    {
        "label": "Button",
        "importPath": "matplotlib.widgets",
        "description": "matplotlib.widgets",
        "isExtraImport": true,
        "detail": "matplotlib.widgets",
        "documentation": {}
    },
    {
        "label": "Slider",
        "importPath": "matplotlib.widgets",
        "description": "matplotlib.widgets",
        "isExtraImport": true,
        "detail": "matplotlib.widgets",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "matplotlib.animation",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "matplotlib.animation",
        "description": "matplotlib.animation",
        "detail": "matplotlib.animation",
        "documentation": {}
    },
    {
        "label": "threading",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "threading",
        "description": "threading",
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "queue",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "queue",
        "description": "queue",
        "detail": "queue",
        "documentation": {}
    },
    {
        "label": "torch.optim",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "torch.optim",
        "description": "torch.optim",
        "detail": "torch.optim",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "seaborn",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "seaborn",
        "description": "seaborn",
        "detail": "seaborn",
        "documentation": {}
    },
    {
        "label": "warnings",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "warnings",
        "description": "warnings",
        "detail": "warnings",
        "documentation": {}
    },
    {
        "label": "SummaryWriter",
        "importPath": "torch.utils.tensorboard",
        "description": "torch.utils.tensorboard",
        "isExtraImport": true,
        "detail": "torch.utils.tensorboard",
        "documentation": {}
    },
    {
        "label": "confusion_matrix",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "classification_report",
        "importPath": "sklearn.metrics",
        "description": "sklearn.metrics",
        "isExtraImport": true,
        "detail": "sklearn.metrics",
        "documentation": {}
    },
    {
        "label": "argparse",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "argparse",
        "description": "argparse",
        "detail": "argparse",
        "documentation": {}
    },
    {
        "label": "ConvNeuralNetwork",
        "importPath": "models",
        "description": "models",
        "isExtraImport": true,
        "detail": "models",
        "documentation": {}
    },
    {
        "label": "get_activation",
        "importPath": "models",
        "description": "models",
        "isExtraImport": true,
        "detail": "models",
        "documentation": {}
    },
    {
        "label": "get_available_activations",
        "importPath": "models",
        "description": "models",
        "isExtraImport": true,
        "detail": "models",
        "documentation": {}
    },
    {
        "label": "CIFAR10DataLoader",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "Trainer",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "Visualizer",
        "importPath": "utils",
        "description": "utils",
        "isExtraImport": true,
        "detail": "utils",
        "documentation": {}
    },
    {
        "label": "GELU",
        "kind": 6,
        "importPath": "models.activations",
        "description": "models.activations",
        "peekOfCode": "class GELU(nn.Module):\n    def __init__(self):\n        super(GELU, self).__init__()\n    def forward(self, x):\n        return 0.5 * x * (1 + torch.tanh(math.sqrt(2 / math.pi) * (x + 0.044715 * torch.pow(x, 3))))\nclass ReLU(nn.Module):\n    def __init__(self):\n        super(ReLU, self).__init__()\n    def forward(self, x):\n        return torch.maximum(torch.zeros_like(x), x)",
        "detail": "models.activations",
        "documentation": {}
    },
    {
        "label": "ReLU",
        "kind": 6,
        "importPath": "models.activations",
        "description": "models.activations",
        "peekOfCode": "class ReLU(nn.Module):\n    def __init__(self):\n        super(ReLU, self).__init__()\n    def forward(self, x):\n        return torch.maximum(torch.zeros_like(x), x)\nclass Tanh(nn.Module):\n    def __init__(self):\n        super(Tanh, self).__init__()\n    def forward(self, x):\n        return torch.tanh(x)",
        "detail": "models.activations",
        "documentation": {}
    },
    {
        "label": "Tanh",
        "kind": 6,
        "importPath": "models.activations",
        "description": "models.activations",
        "peekOfCode": "class Tanh(nn.Module):\n    def __init__(self):\n        super(Tanh, self).__init__()\n    def forward(self, x):\n        return torch.tanh(x)\nclass Sigmoid(nn.Module):\n    def __init__(self):\n        super(Sigmoid, self).__init__()\n    def forward(self, x):\n        return torch.sigmoid(x)",
        "detail": "models.activations",
        "documentation": {}
    },
    {
        "label": "Sigmoid",
        "kind": 6,
        "importPath": "models.activations",
        "description": "models.activations",
        "peekOfCode": "class Sigmoid(nn.Module):\n    def __init__(self):\n        super(Sigmoid, self).__init__()\n    def forward(self, x):\n        return torch.sigmoid(x)\nclass Step(nn.Module):\n    def __init__(self, threshold=0.0):\n        super(Step, self).__init__()\n        self.threshold = threshold\n    def forward(self, x):",
        "detail": "models.activations",
        "documentation": {}
    },
    {
        "label": "Step",
        "kind": 6,
        "importPath": "models.activations",
        "description": "models.activations",
        "peekOfCode": "class Step(nn.Module):\n    def __init__(self, threshold=0.0):\n        super(Step, self).__init__()\n        self.threshold = threshold\n    def forward(self, x):\n        return (x > self.threshold).float()\nclass Softmax(nn.Module):\n    def __init__(self, dim=-1):\n        super(Softmax, self).__init__()\n        self.dim = dim",
        "detail": "models.activations",
        "documentation": {}
    },
    {
        "label": "Softmax",
        "kind": 6,
        "importPath": "models.activations",
        "description": "models.activations",
        "peekOfCode": "class Softmax(nn.Module):\n    def __init__(self, dim=-1):\n        super(Softmax, self).__init__()\n        self.dim = dim\n    def forward(self, x):\n        return F.softmax(x, dim=self.dim)\nclass Swish(nn.Module):\n    def __init__(self):\n        super(Swish, self).__init__()\n    def forward(self, x):",
        "detail": "models.activations",
        "documentation": {}
    },
    {
        "label": "Swish",
        "kind": 6,
        "importPath": "models.activations",
        "description": "models.activations",
        "peekOfCode": "class Swish(nn.Module):\n    def __init__(self):\n        super(Swish, self).__init__()\n    def forward(self, x):\n        return x * torch.sigmoid(x)\nclass Mish(nn.Module):\n    def __init__(self):\n        super(Mish, self).__init__()\n    def forward(self, x):\n        return x * torch.tanh(F.softplus(x))",
        "detail": "models.activations",
        "documentation": {}
    },
    {
        "label": "Mish",
        "kind": 6,
        "importPath": "models.activations",
        "description": "models.activations",
        "peekOfCode": "class Mish(nn.Module):\n    def __init__(self):\n        super(Mish, self).__init__()\n    def forward(self, x):\n        return x * torch.tanh(F.softplus(x))\nclass LeakyReLU(nn.Module):\n    def __init__(self, negative_slope=0.01):\n        super(LeakyReLU, self).__init__()\n        self.negative_slope = negative_slope\n    def forward(self, x):",
        "detail": "models.activations",
        "documentation": {}
    },
    {
        "label": "LeakyReLU",
        "kind": 6,
        "importPath": "models.activations",
        "description": "models.activations",
        "peekOfCode": "class LeakyReLU(nn.Module):\n    def __init__(self, negative_slope=0.01):\n        super(LeakyReLU, self).__init__()\n        self.negative_slope = negative_slope\n    def forward(self, x):\n        return F.leaky_relu(x, negative_slope=self.negative_slope)\nclass ELU(nn.Module):\n    def __init__(self, alpha=1.0):\n        super(ELU, self).__init__()\n        self.alpha = alpha",
        "detail": "models.activations",
        "documentation": {}
    },
    {
        "label": "ELU",
        "kind": 6,
        "importPath": "models.activations",
        "description": "models.activations",
        "peekOfCode": "class ELU(nn.Module):\n    def __init__(self, alpha=1.0):\n        super(ELU, self).__init__()\n        self.alpha = alpha\n    def forward(self, x):\n        return F.elu(x, alpha=self.alpha)\nclass PReLU(nn.Module):\n    def __init__(self, num_parameters=1, init=0.25):\n        super(PReLU, self).__init__()\n        self.num_parameters = num_parameters",
        "detail": "models.activations",
        "documentation": {}
    },
    {
        "label": "PReLU",
        "kind": 6,
        "importPath": "models.activations",
        "description": "models.activations",
        "peekOfCode": "class PReLU(nn.Module):\n    def __init__(self, num_parameters=1, init=0.25):\n        super(PReLU, self).__init__()\n        self.num_parameters = num_parameters\n        self.weight = nn.Parameter(torch.full((num_parameters,), init))\n    def forward(self, x):\n        return F.prelu(x, self.weight)\nclass SELU(nn.Module):\n    def __init__(self):\n        super(SELU, self).__init__()",
        "detail": "models.activations",
        "documentation": {}
    },
    {
        "label": "SELU",
        "kind": 6,
        "importPath": "models.activations",
        "description": "models.activations",
        "peekOfCode": "class SELU(nn.Module):\n    def __init__(self):\n        super(SELU, self).__init__()\n    def forward(self, x):\n        return F.selu(x)\nclass Hardswish(nn.Module):\n    def __init__(self):\n        super(Hardswish, self).__init__()\n    def forward(self, x):\n        return x * F.relu6(x + 3) / 6",
        "detail": "models.activations",
        "documentation": {}
    },
    {
        "label": "Hardswish",
        "kind": 6,
        "importPath": "models.activations",
        "description": "models.activations",
        "peekOfCode": "class Hardswish(nn.Module):\n    def __init__(self):\n        super(Hardswish, self).__init__()\n    def forward(self, x):\n        return x * F.relu6(x + 3) / 6\nclass SiLU(nn.Module):\n    def __init__(self):\n        super(SiLU, self).__init__()\n    def forward(self, x):\n        return F.silu(x)",
        "detail": "models.activations",
        "documentation": {}
    },
    {
        "label": "SiLU",
        "kind": 6,
        "importPath": "models.activations",
        "description": "models.activations",
        "peekOfCode": "class SiLU(nn.Module):\n    def __init__(self):\n        super(SiLU, self).__init__()\n    def forward(self, x):\n        return F.silu(x)\ndef get_activation(activation_name):\n    \"\"\"\n    Factory function to get activation function by name.\n    Args:\n        activation_name (str): Name of the activation function",
        "detail": "models.activations",
        "documentation": {}
    },
    {
        "label": "get_activation",
        "kind": 2,
        "importPath": "models.activations",
        "description": "models.activations",
        "peekOfCode": "def get_activation(activation_name):\n    \"\"\"\n    Factory function to get activation function by name.\n    Args:\n        activation_name (str): Name of the activation function\n    Returns:\n        nn.Module: The corresponding activation function\n    \"\"\"\n    activation_map = {\n        'gelu': GELU(),",
        "detail": "models.activations",
        "documentation": {}
    },
    {
        "label": "get_available_activations",
        "kind": 2,
        "importPath": "models.activations",
        "description": "models.activations",
        "peekOfCode": "def get_available_activations():\n    \"\"\"\n    Get list of all available activation functions.\n    Returns:\n        list: List of available activation function names\n    \"\"\"\n    return ['gelu', 'relu', 'tanh', 'sigmoid', 'step', 'softmax', 'swish',\n            'mish', 'leakyrelu', 'elu', 'prelu', 'selu', 'hardswish', 'silu']",
        "detail": "models.activations",
        "documentation": {}
    },
    {
        "label": "NeuralNetwork",
        "kind": 6,
        "importPath": "models.network",
        "description": "models.network",
        "peekOfCode": "class NeuralNetwork(nn.Module):\n    def __init__(self, input_size, hidden_sizes, output_size, activation='relu', dropout_rate=0.2):\n        \"\"\"\n        A flexible neural network implementation.\n        Args:\n            input_size (int): Size of input features\n            hidden_sizes (list): List of hidden layer sizes\n            output_size (int): Size of output layer\n            activation (str): Activation function name ('gelu', 'relu', 'tanh')\n            dropout_rate (float): Dropout rate for regularization",
        "detail": "models.network",
        "documentation": {}
    },
    {
        "label": "ConvNeuralNetwork",
        "kind": 6,
        "importPath": "models.network",
        "description": "models.network",
        "peekOfCode": "class ConvNeuralNetwork(nn.Module):\n    def __init__(self, input_channels=3, num_classes=10, activation='relu', dropout_rate=0.2):\n        \"\"\"\n        Convolutional Neural Network for image classification (e.g., CIFAR-10).\n        Args:\n            input_channels (int): Number of input channels (3 for RGB)\n            num_classes (int): Number of output classes\n            activation (str): Activation function name\n            dropout_rate (float): Dropout rate\n        \"\"\"",
        "detail": "models.network",
        "documentation": {}
    },
    {
        "label": "CIFAR10DataLoader",
        "kind": 6,
        "importPath": "utils.data_loader",
        "description": "utils.data_loader",
        "peekOfCode": "class CIFAR10DataLoader:\n    def __init__(self, batch_size=32, validation_split=0.1, data_dir='./data',\n                 normalize=True, augment_train=True):\n        \"\"\"\n        CIFAR-10 data loader with train/validation/test splits.\n        Args:\n            batch_size (int): Batch size for data loading\n            validation_split (float): Fraction of training data to use for validation\n            data_dir (str): Directory to store/load CIFAR-10 data\n            normalize (bool): Whether to normalize the data",
        "detail": "utils.data_loader",
        "documentation": {}
    },
    {
        "label": "create_cifar10_loader",
        "kind": 2,
        "importPath": "utils.data_loader",
        "description": "utils.data_loader",
        "peekOfCode": "def create_cifar10_loader(batch_size=32, validation_split=0.1, data_dir='./data'):\n    \"\"\"\n    Convenience function to create CIFAR-10 data loader.\n    Args:\n        batch_size (int): Batch size\n        validation_split (float): Validation split ratio\n        data_dir (str): Data directory\n    Returns:\n        CIFAR10DataLoader: Configured data loader\n    \"\"\"",
        "detail": "utils.data_loader",
        "documentation": {}
    },
    {
        "label": "InteractivePropagationPanel",
        "kind": 6,
        "importPath": "utils.interactive_propagation_panel",
        "description": "utils.interactive_propagation_panel",
        "peekOfCode": "class InteractivePropagationPanel:\n    \"\"\"\n    Interactive panel showing neuron-synapse interactions during propagation.\n    Features:\n    - Detailed synapse visualization with weight values\n    - Step-by-step signal flow through connections\n    - Weighted sum calculation at each neuron\n    - Activation function visualization\n    - Gradient flow through synapses (backprop)\n    \"\"\"",
        "detail": "utils.interactive_propagation_panel",
        "documentation": {}
    },
    {
        "label": "launch_propagation_panel",
        "kind": 2,
        "importPath": "utils.interactive_propagation_panel",
        "description": "utils.interactive_propagation_panel",
        "peekOfCode": "def launch_propagation_panel(model, data_loader, device):\n    \"\"\"\n    Launch the interactive propagation panel.\n    Args:\n        model: PyTorch model\n        data_loader: DataLoader with samples\n        device: Device to run on\n    \"\"\"\n    print(\"\\n\" + \"=\"*70)\n    print(\"🚀 LAUNCHING INTERACTIVE PROPAGATION PANEL\")",
        "detail": "utils.interactive_propagation_panel",
        "documentation": {}
    },
    {
        "label": "LiveNetworkVisualizer",
        "kind": 6,
        "importPath": "utils.live_network_viz",
        "description": "utils.live_network_viz",
        "peekOfCode": "class LiveNetworkVisualizer:\n    \"\"\"\n    Real-time visualization of neural network with circles (neurons) and arrows (connections).\n    Shows live neuron activations, weight changes, and data flow during training.\n    \"\"\"\n    def __init__(self, model, max_neurons_per_layer=8, update_frequency=20):\n        \"\"\"\n        Initialize live network visualizer.\n        Args:\n            model: PyTorch model to visualize",
        "detail": "utils.live_network_viz",
        "documentation": {}
    },
    {
        "label": "LivePerceptronNetwork",
        "kind": 6,
        "importPath": "utils.live_network_viz",
        "description": "utils.live_network_viz",
        "peekOfCode": "class LivePerceptronNetwork:\n    \"\"\"\n    Simplified live visualization of perceptron network structure.\n    Shows a clear network diagram with circles and arrows.\n    \"\"\"\n    def __init__(self, network_structure=[3, 4, 4, 2]):\n        \"\"\"\n        Initialize live perceptron network visualization.\n        Args:\n            network_structure: List of neurons per layer [input, hidden1, hidden2, output]",
        "detail": "utils.live_network_viz",
        "documentation": {}
    },
    {
        "label": "create_live_network_demo",
        "kind": 2,
        "importPath": "utils.live_network_viz",
        "description": "utils.live_network_viz",
        "peekOfCode": "def create_live_network_demo():\n    \"\"\"Create a demo of live network visualization.\"\"\"\n    print(\"🎨 Creating live perceptron network visualization...\")\n    # Create a simple network structure\n    network = LivePerceptronNetwork([3, 5, 4, 2])\n    network.start_visualization()\n    print(\"🎬 Starting animation... (Press Ctrl+C to stop)\")\n    try:\n        for i in range(100):  # Run for 100 iterations\n            print(f\"📊 Iteration {i+1}/100 - Watch the network process data!\")",
        "detail": "utils.live_network_viz",
        "documentation": {}
    },
    {
        "label": "Brightness",
        "kind": 5,
        "importPath": "utils.live_network_viz",
        "description": "utils.live_network_viz",
        "peekOfCode": "Brightness = Activation Level    Arrow Thickness = Weight Strength\n\"\"\"\n        self.ax.text(5, 0.5, legend_text, ha='center', va='center', fontsize=10,\n                    bbox=dict(boxstyle=\"round,pad=0.5\", facecolor='lightyellow', alpha=0.8))\n    def update(self):\n        \"\"\"Update the visualization with current network state.\"\"\"\n        if not self.is_running:\n            return\n        self.batch_count += 1\n    def _animate_network(self, frame):",
        "detail": "utils.live_network_viz",
        "documentation": {}
    },
    {
        "label": "LiveTrainer",
        "kind": 6,
        "importPath": "utils.live_trainer",
        "description": "utils.live_trainer",
        "peekOfCode": "class LiveTrainer(Trainer):\n    \"\"\"\n    Enhanced trainer with real-time monitoring capabilities.\n    Shows live training progress, layer activations, and network behavior.\n    \"\"\"\n    def __init__(self, model, train_loader, val_loader=None, test_loader=None,\n                 device=None, save_dir='./checkpoints', enable_live_monitoring=True):\n        \"\"\"\n        Initialize live trainer with real-time monitoring.\n        Args:",
        "detail": "utils.live_trainer",
        "documentation": {}
    },
    {
        "label": "PerceptronVisualizer",
        "kind": 6,
        "importPath": "utils.monitor",
        "description": "utils.monitor",
        "peekOfCode": "class PerceptronVisualizer:\n    \"\"\"Visualizes the structure and operation of perceptrons and neural networks.\"\"\"\n    def __init__(self, save_dir='./visualizations'):\n        self.save_dir = save_dir\n        os.makedirs(save_dir, exist_ok=True)\n    def plot_single_perceptron(self, weights, bias, inputs=None, output=None,\n                              activation_name='linear', save_path=None):\n        \"\"\"\n        Visualize a single perceptron with weights, bias, and data flow.\n        Args:",
        "detail": "utils.monitor",
        "documentation": {}
    },
    {
        "label": "LayerMonitor",
        "kind": 6,
        "importPath": "utils.monitor",
        "description": "utils.monitor",
        "peekOfCode": "class LayerMonitor:\n    \"\"\"Monitor layer-by-layer operations during forward pass.\"\"\"\n    def __init__(self):\n        self.activations = {}\n        self.gradients = {}\n        self.hooks = []\n    def register_hooks(self, model):\n        \"\"\"Register forward and backward hooks to monitor layer operations.\"\"\"\n        def forward_hook(name):\n            def hook(module, input, output):",
        "detail": "utils.monitor",
        "documentation": {}
    },
    {
        "label": "ActivationAnalyzer",
        "kind": 6,
        "importPath": "utils.monitor",
        "description": "utils.monitor",
        "peekOfCode": "class ActivationAnalyzer:\n    \"\"\"Analyze and visualize activation function behaviors.\"\"\"\n    def __init__(self, save_dir='./visualizations'):\n        self.save_dir = save_dir\n        os.makedirs(save_dir, exist_ok=True)\n    def plot_activation_functions(self, activation_names, x_range=(-5, 5), save_path=None):\n        \"\"\"\n        Plot multiple activation functions for comparison.\n        Args:\n            activation_names (list): List of activation function names",
        "detail": "utils.monitor",
        "documentation": {}
    },
    {
        "label": "RealTimeMonitor",
        "kind": 6,
        "importPath": "utils.monitor",
        "description": "utils.monitor",
        "peekOfCode": "class RealTimeMonitor:\n    \"\"\"Monitor training progress in real-time.\"\"\"\n    def __init__(self):\n        self.training_data = defaultdict(list)\n        self.epoch_data = defaultdict(list)\n    def update(self, epoch, batch, loss, accuracy, lr=None):\n        \"\"\"Update monitoring data.\"\"\"\n        self.training_data['epoch'].append(epoch)\n        self.training_data['batch'].append(batch)\n        self.training_data['loss'].append(loss)",
        "detail": "utils.monitor",
        "documentation": {}
    },
    {
        "label": "LiveTrainingMonitor",
        "kind": 6,
        "importPath": "utils.realtime_monitor",
        "description": "utils.realtime_monitor",
        "peekOfCode": "class LiveTrainingMonitor:\n    \"\"\"Real-time training monitor with live updating plots.\"\"\"\n    def __init__(self, update_frequency=10, max_points=1000):\n        \"\"\"\n        Initialize real-time training monitor.\n        Args:\n            update_frequency (int): Update plots every N batches\n            max_points (int): Maximum points to keep in memory\n        \"\"\"\n        self.update_frequency = update_frequency",
        "detail": "utils.realtime_monitor",
        "documentation": {}
    },
    {
        "label": "LiveLayerMonitor",
        "kind": 6,
        "importPath": "utils.realtime_monitor",
        "description": "utils.realtime_monitor",
        "peekOfCode": "class LiveLayerMonitor:\n    \"\"\"Monitor layer activations and weights in real-time.\"\"\"\n    def __init__(self, model, update_frequency=50):\n        \"\"\"\n        Initialize live layer monitor.\n        Args:\n            model: PyTorch model to monitor\n            update_frequency (int): Update every N batches\n        \"\"\"\n        self.model = model",
        "detail": "utils.realtime_monitor",
        "documentation": {}
    },
    {
        "label": "LiveNeuralNetworkVisualizer",
        "kind": 6,
        "importPath": "utils.realtime_monitor",
        "description": "utils.realtime_monitor",
        "peekOfCode": "class LiveNeuralNetworkVisualizer:\n    \"\"\"Real-time visualization of neural network thinking process.\"\"\"\n    def __init__(self, model):\n        \"\"\"\n        Initialize live neural network visualizer.\n        Args:\n            model: PyTorch model to visualize\n        \"\"\"\n        self.model = model\n        self.fig = None",
        "detail": "utils.realtime_monitor",
        "documentation": {}
    },
    {
        "label": "create_comprehensive_monitor",
        "kind": 2,
        "importPath": "utils.realtime_monitor",
        "description": "utils.realtime_monitor",
        "peekOfCode": "def create_comprehensive_monitor(model):\n    \"\"\"Create a comprehensive real-time monitoring system.\"\"\"\n    class ComprehensiveMonitor:\n        def __init__(self, model):\n            self.training_monitor = LiveTrainingMonitor()\n            self.layer_monitor = LiveLayerMonitor(model)\n            self.network_visualizer = LiveNeuralNetworkVisualizer(model)\n        def start_all(self):\n            \"\"\"Start all monitoring components.\"\"\"\n            print(\"🚀 Starting comprehensive real-time monitoring...\")",
        "detail": "utils.realtime_monitor",
        "documentation": {}
    },
    {
        "label": "Trainer",
        "kind": 6,
        "importPath": "utils.trainer",
        "description": "utils.trainer",
        "peekOfCode": "class Trainer:\n    def __init__(self, model, train_loader, val_loader=None, test_loader=None,\n                 device=None, save_dir='./checkpoints'):\n        \"\"\"\n        Neural network trainer with comprehensive training utilities.\n        Args:\n            model (nn.Module): The neural network model to train\n            train_loader (DataLoader): Training data loader\n            val_loader (DataLoader, optional): Validation data loader\n            test_loader (DataLoader, optional): Test data loader",
        "detail": "utils.trainer",
        "documentation": {}
    },
    {
        "label": "Visualizer",
        "kind": 6,
        "importPath": "utils.visualization",
        "description": "utils.visualization",
        "peekOfCode": "class Visualizer:\n    def __init__(self, class_names=None):\n        \"\"\"\n        Visualization utilities for neural network training and evaluation.\n        Args:\n            class_names (list, optional): List of class names for labeling\n        \"\"\"\n        self.class_names = class_names\n        plt.style.use('default')\n    def plot_training_history(self, history, save_path=None):",
        "detail": "utils.visualization",
        "documentation": {}
    },
    {
        "label": "create_visualizer",
        "kind": 2,
        "importPath": "utils.visualization",
        "description": "utils.visualization",
        "peekOfCode": "def create_visualizer(class_names=None):\n    \"\"\"\n    Convenience function to create a visualizer.\n    Args:\n        class_names (list, optional): List of class names\n    Returns:\n        Visualizer: Configured visualizer instance\n    \"\"\"\n    return Visualizer(class_names=class_names)",
        "detail": "utils.visualization",
        "documentation": {}
    },
    {
        "label": "launch_interactive_propagation",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def launch_interactive_propagation(activation='relu'):\n    \"\"\"\n    Launch interactive propagation panel showing forward and backward passes.\n    Args:\n        activation (str): Activation function to use\n    \"\"\"\n    print(\"🧠\" + \"=\"*60 + \"🧠\")\n    print(\"    INTERACTIVE PROPAGATION PANEL\")\n    print(\"    Forward & Backward Pass with Synapses\")\n    print(\"🧠\" + \"=\"*60 + \"🧠\")",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "visualize_network",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def visualize_network(activation='relu'):\n    \"\"\"\n    Visualize neural network structure in real-time.\n    Args:\n        activation (str): Activation function to use\n    \"\"\"\n    print(\"🧠\" + \"=\"*60 + \"🧠\")\n    print(\"    LIVE NEURAL NETWORK VISUALIZATION\")\n    print(\"🧠\" + \"=\"*60 + \"🧠\")\n    print()",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "train_model",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def train_model(activation, epochs=10, batch_size=32, lr=0.001, enable_monitoring=False):\n    \"\"\"\n    Train a model with specified activation function.\n    Args:\n        activation (str): Activation function name\n        epochs (int): Number of training epochs\n        batch_size (int): Batch size\n        lr (float): Learning rate\n        enable_monitoring (bool): Enable live training monitoring\n    Returns:",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "compare_activations",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def compare_activations(activations, epochs=10, batch_size=32, lr=0.001, enable_monitoring=False):\n    \"\"\"\n    Compare different activation functions.\n    Args:\n        activations (list): List of activation function names\n        epochs (int): Number of training epochs\n        batch_size (int): Batch size\n        lr (float): Learning rate\n        enable_monitoring (bool): Enable live monitoring\n    \"\"\"",
        "detail": "main",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def main():\n    # Get available activations dynamically\n    available_activations = get_available_activations()\n    activation_choices = available_activations + ['all', 'modern', 'classic']\n    parser = argparse.ArgumentParser(description='Train neural networks with different activation functions')\n    parser.add_argument('--activation', type=str, default='relu',\n                       choices=activation_choices,\n                       help='Activation function to use (default: relu). Use \"all\" for all functions, \"modern\" for recent ones, \"classic\" for traditional ones.')\n    parser.add_argument('--epochs', type=int, default=10,\n                       help='Number of training epochs (default: 10)')",
        "detail": "main",
        "documentation": {}
    }
]